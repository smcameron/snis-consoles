<html>
<body>
<h2 align=center>SNIS console Notes</h2>
<p>The basic idea is that we can run many (but not all) of the Space Nerds in Space
bridge stations on
a Raspberry Pi, and have an arduino connected to the Pi, and connected to the arduino
can be a load of potentiometers and switches and LEDs.  These potentiometers and
switches can be logically connnected to buttons and sliders within the game.  The arduino
can poll the state of the switches and potentiometers and report changes to the game
via the USB serial back to a process on the the raspberry pi which can then feed these
changes into the game via the interface provided by
<a href="https://github.com/smcameron/space-nerds-in-space/blob/master/snis-device-io.h">snis-device-io.h</a>.
Likewise, LEDS for warning lights, etc. can be controlled from the game via USB serial to
to the arduino.  In this way we can build a physical console for each of the stations to
make the game seem a little more like a spaceship and little less like a computer game.

<p>Why Arduino?  Because arduino is accessible and open source.  It's possible other
people besides me may want to build something like this, and Arduino is the easiest,
most well-known and popular thing in its class, and most likely to be something that
other people will be <em>able</em> to work with.

<hr>
<b>Sat Feb  1 11:04:55 EST 2020</b>
<p>Going through the screens, here are the switches and pots needed:

<ol>
<li>Navigation:
<ul>
<li>3 pots (zoom, impulse, warp)
<li>8 switches
<li>Joystick, throttle and rudder pedals
</ul>
<li>Engineering:
<ul>
<li>19 pots
<li>5 switches
</ul>
<li>Damage Control (combined with engineering):
<ul>
<li>0 pots
<li>1 DPDT switch (auto/manual), 1 switch, 1 joystick, 1 pushbutton, 1 DPDT switch (eng/damcon)
</ul>
<li>Science:
<ul>
<li>8 switches/buttons
<li>4 buttons for controlling beam
<li>6 buttons for controlling LRS view
<li>1 pot for range
</ul>
<li>Comms
<ul>
<li>20 buttons
<li>1 pot
<li>LED for missile lock
<li>LED for red alert
</ul>
</ol>

<hr>
<b>Fri Jan 31 10:35:58 EST 2020</b>
<p>Was talking with Rob last night at HackRVA, and we are going to build a vacuum forming
machine.  This should help with building the cases for the consoles.  I have a few ideas
about how to paint them.  One idea, vacuum form them from clear PETG, then paint the inside
with silver paint.  Should look like mylar, more or less.  Not sure I like that idea.  Another
idea, put some HVAC tape on select edges, paint with black, dark gray, or hammered metal, then
sand off a bit to expose some of the silver HVAC tape.  I think I'll probably do the latter
method.
<hr>
<b>Wed Jan 29 10:23:41 EST 2020</b>
<p>I changed the protocol used over the serial USB so that the '#' is replaced by the first
letter of the station, so 'E' for engineering, 'C' for comms, 'W' for weapons, 'S' for science,
'D' for demon, 'N' for navigation.  Only engineering is implemented yet.  I'm using a #define
to control which station the code compiles for.
<p>Ordered 20 ULN2803 darlington arrays to drive LEDs from amazon, should be here in 2-4 weeks.
Ordered some shift registers and male pin headers from futurlec, who knows when those will arrive.
(I noticed there are some male pin heads lying around HackRVA though, so no need to wait
for those, ha.)
<p>Looking into building a vacuum forming machine to use for making the console cases.
<hr>
<b>Sat Jan 25 19:38:29 EST 2020</b>
<p>Made some progress, there's a new program in the space-nerds-in-space repo called snis_arduino
that reads from the arduino and passes along commands from the arduino to snis_client.  I updated
the program which runs on the arduino itself (snis-console.c.ino) so it actually works.  The main
change I made was to switch to a text protocol from binary. This avoids de-syncing
as I can look for a newline to delimit the commands. Now the commands from the arduino to the
host (raspberry pi) are of the form: "#xxx=yyy\n", where xxx is the input number (0 - 31) and
yyy is the value for that input.  The values are only reported to the host if they differ from
the previous sampling by more than 3.

<p>Another change I made on the host side (snis_arduino) has to do with the problem I was seeing
in which it would read a little bit then quit upon encountering EOF.  It turns out that reading
from /dev/ttyACM0 is apparently non-blocking, despite not opening it with O_NONBLOCK, which
sort of surprises me.  So I changed the code to simply wait for a few milliseconds and try again
upon encountering EOF, and this seemed to make it work.

<p>Video here: <a href="https://www.youtube.com/watch?v=51ljGNx3px4">https://www.youtube.com/watch?v=51ljGNx3px4</a>.

<hr>
<b>Wed Jan 22 11:36:04 EST 2020</b>
Here is rough drawing for a circuit for a station.  There are two 16 channel multiplexers
allowing for 32 potentiometers or switches.  The channels on the multiplexers are not
selected independently, but in parallel.  Two analog inputs on the arduino sample one
channel from each of the two multiplexers.

<p align=center><img src="snis-console-circuit-sketch-2020-01-22.jpg", width=85%>

<p>On the output side, two daisy chained shift registers allow up to 16 LEDs to be
controlled. Likely I will need to add NPN transistors to drive each of the LEDs to avoid
drawing too much current from the shift registers.

<p>Pseudocode for the arduino will be something along these lines:

<pre>

	static int new_value[32] = { 0 };
	static int old_value[32] = { 0 };
	static int led_status[16] = { 0 };

	setup()
	{
		Set up 4 digital outputs D4 thru D7 for selecting the multiplexer channels.
		Set up 2 analog inputs for the multiplexer signals.
		Set up 3 digital outputs for the shift register controls
		set up interrupt handler for incoming serial data
	}

	select_multiplexer_channel(int n)
	{
		D4 = i &amp; 0x01;
		D5 = (i &gt;&gt; 1) & 0x01;
		D5 = (i &gt;&gt; 2) & 0x01;
		D5 = (i &gt;&gt; 3) & 0x01;
	}

	sample_inputs_from_multiplexer(int new_value[])
	{

		for (int i = 0; i &lt; 16; i++) {
			select_multiplexer_channel(i);
			new_value[i] = read_multiplexer(0);
			new_value[i + 16] = read_multiplexer(1);
		}
	}

	transmit_changes(new_value, old_value)
	{
		for (i = 0; i &lt; 32; i++) {
			if (old_value[i] != new_value[i])
				transmit_value(i, new_value[i]);
		}
	}

	update_led_status()
	{
		/* Shift LED data out to shift register */
		for (i = 0; i &lt; 16; i++) {
			set DS = 0;
			set ST_CP = led_status[i];
			set DS = 1;
		}
		set DS = 0;

		/* Latch LED data (need to double check this is how it works) */
		set SH_CP = 0;
		set SH_CP = 1;
		set SH_CP = 0;
	}

	serial_interrupt_handler()
	{
		/* still need to work out whatever the protocol is for LED data */
		/* Could be just pairs of bytes. */
		get_character_from_serial()
		decode_character();
	}

	loop()
	{
		sample_inputs_from_multiplexer(new_value);
		transmit_changes(new_value, old_value);
		memcpy(old_value, new_value, sizeof(old_value));
		update_led_status();
	}
</pre>
<hr>
</body>
</html>
